"use strict";(globalThis.webpackChunkunmanic_documentation=globalThis.webpackChunkunmanic_documentation||[]).push([[464],{28453(e,n,i){i.d(n,{R:()=>d,x:()=>r});var t=i(96540);const a={},s=t.createContext(a);function d(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:d(e.components),t.createElement(s.Provider,{value:n},e.children)}},58473(e,n,i){i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>d,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"development/writing_plugins/advanced_plugin_patterns","title":"Advanced","description":"Advanced Plugin Development Patterns","source":"@site/docs/development/writing_plugins/advanced.mdx","sourceDirName":"development/writing_plugins","slug":"/development/writing_plugins/advanced_plugin_patterns","permalink":"/docs/development/writing_plugins/advanced_plugin_patterns","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Advanced","description":"Advanced Plugin Development Patterns","id":"advanced_plugin_patterns"},"sidebar":"docs","previous":{"title":"Plugin Runners","permalink":"/docs/development/writing_plugins/plugin_runner_types"},"next":{"title":"Creating Your Own Repository","permalink":"/docs/development/plugin_repos/creating_your_own_repo"}}');var a=i(74848),s=i(28453);const d={title:"Advanced",description:"Advanced Plugin Development Patterns",id:"advanced_plugin_patterns"},r=void 0,l={},c=[{value:"Hardware Acceleration Detection",id:"hardware-acceleration-detection",level:2},{value:"Detecting NVIDIA GPUs",id:"detecting-nvidia-gpus",level:3},{value:"Detecting VAAPI Devices (Intel/AMD on Linux)",id:"detecting-vaapi-devices-intelamd-on-linux",level:3},{value:"Detecting Intel QSV Devices",id:"detecting-intel-qsv-devices",level:3},{value:"Dynamic Form Settings Based on Hardware",id:"dynamic-form-settings-based-on-hardware",level:3},{value:"Best Practices",id:"best-practices",level:3}];function o(e){const n={code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"This page covers advanced patterns for plugin development."}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"hardware-acceleration-detection",children:"Hardware Acceleration Detection"}),"\n",(0,a.jsx)(n.p,{children:"Plugins that perform video encoding can leverage hardware acceleration (GPU encoding) for significantly faster processing. This section covers how to detect available hardware in your plugin."}),"\n",(0,a.jsx)(n.h3,{id:"detecting-nvidia-gpus",children:"Detecting NVIDIA GPUs"}),"\n",(0,a.jsxs)(n.p,{children:["Use ",(0,a.jsx)(n.code,{children:"nvidia-smi"})," to detect NVIDIA GPUs and their capabilities:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"import subprocess\nimport re\n\ndef list_available_nvidia_devices():\n    \"\"\"\n    Return a list of available NVIDIA CUDA devices.\n    \"\"\"\n    gpu_list = []\n    try:\n        result = subprocess.check_output(['nvidia-smi', '-L'], encoding='utf-8')\n        # Parse output like: GPU 0: NVIDIA GeForce RTX 3080 (UUID: GPU-xxxx)\n        gpu_info = re.findall(r'GPU (\\d+): (.+) \\(UUID: (.+)\\)', result)\n        for gpu_id, gpu_name, gpu_uuid in gpu_info:\n            gpu_list.append({\n                'device_id': gpu_id,\n                'name': gpu_name,\n                'uuid': gpu_uuid,\n            })\n    except FileNotFoundError:\n        # nvidia-smi not installed\n        pass\n    except subprocess.CalledProcessError:\n        # Command failed - no NVIDIA GPU present\n        pass\n    return gpu_list\n"})}),"\n",(0,a.jsx)(n.h3,{id:"detecting-vaapi-devices-intelamd-on-linux",children:"Detecting VAAPI Devices (Intel/AMD on Linux)"}),"\n",(0,a.jsxs)(n.p,{children:["VAAPI devices appear as render nodes in ",(0,a.jsx)(n.code,{children:"/dev/dri/"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'import os\n\ndef list_available_vaapi_devices():\n    """\n    Return a list of available VAAPI render devices.\n    """\n    devices = []\n    dri_path = "/dev/dri"\n\n    if os.path.exists(dri_path):\n        for device in sorted(os.listdir(dri_path)):\n            if device.startswith(\'render\'):\n                devices.append({\n                    \'device\': device,\n                    \'path\': os.path.join(dri_path, device),\n                })\n    return devices\n'})}),"\n",(0,a.jsx)(n.h3,{id:"detecting-intel-qsv-devices",children:"Detecting Intel QSV Devices"}),"\n",(0,a.jsx)(n.p,{children:"Intel Quick Sync Video requires checking both for render devices and the Intel vendor ID:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'import os\nfrom pathlib import Path\n\ndef get_intel_qsv_device():\n    """\n    Find an Intel render device for QSV encoding.\n    Returns the device path (e.g., \'/dev/dri/renderD128\') or None if not found.\n    """\n    dri_path = Path(\'/dev/dri\')\n    if not dri_path.exists():\n        return None\n\n    for device in dri_path.glob("render*"):\n        # Check vendor ID in sysfs\n        vendor_path = Path(f"/sys/class/drm/{device.name}/device/vendor")\n        if vendor_path.exists():\n            vendor_id = vendor_path.read_text().strip()\n            if "0x8086" in vendor_id:  # Intel vendor ID\n                return str(device)\n    return None\n'})}),"\n",(0,a.jsx)(n.h3,{id:"dynamic-form-settings-based-on-hardware",children:"Dynamic Form Settings Based on Hardware"}),"\n",(0,a.jsx)(n.p,{children:"Update your plugin's form settings to show/hide encoder options based on detected hardware:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'def get_encoder_form_settings(self):\n    """\n    Dynamically configure encoder options based on available hardware.\n    """\n    nvidia_devices = list_available_nvidia_devices()\n    vaapi_devices = list_available_vaapi_devices()\n    qsv_device = get_intel_qsv_device()\n\n    options = [\n        {"value": "libx264", "label": "CPU - libx264 (always available)"},\n        {"value": "libx265", "label": "CPU - libx265 (always available)"},\n    ]\n\n    if nvidia_devices:\n        options.append({"value": "h264_nvenc", "label": "NVIDIA - h264_nvenc"})\n        options.append({"value": "hevc_nvenc", "label": "NVIDIA - hevc_nvenc"})\n\n    if qsv_device:\n        options.append({"value": "h264_qsv", "label": "Intel QSV - h264_qsv"})\n        options.append({"value": "hevc_qsv", "label": "Intel QSV - hevc_qsv"})\n\n    if vaapi_devices:\n        options.append({"value": "h264_vaapi", "label": "VAAPI - h264_vaapi"})\n        options.append({"value": "hevc_vaapi", "label": "VAAPI - hevc_vaapi"})\n\n    return {\n        "label": "Video Encoder",\n        "input_type": "select",\n        "select_options": options,\n    }\n'})}),"\n",(0,a.jsx)(n.h3,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Always provide a CPU fallback"})," - Hardware may not be available in all environments"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Check at form generation time"})," - Detect hardware when building settings forms so users only see valid options"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Handle detection failures gracefully"})," - Wrap detection code in try/except blocks"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Cache detection results"})," - Hardware doesn't change during runtime, so detect once and reuse"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Log detection results"})," - Help users troubleshoot by logging which hardware was detected"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(o,{...e})}):o(e)}}}]);