"use strict";(globalThis.webpackChunkunmanic_documentation=globalThis.webpackChunkunmanic_documentation||[]).push([[5990],{18430(e,n,i){i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"using_unmanic/workflow","title":"Unmanic Workflow","description":"How Unmanic processes files from discovery to completion","source":"@site/docs/using_unmanic/workflow.mdx","sourceDirName":"using_unmanic","slug":"/using_unmanic/workflow","permalink":"/docs/using_unmanic/workflow","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Unmanic Workflow","description":"How Unmanic processes files from discovery to completion","id":"workflow"},"sidebar":"docs","previous":{"title":"Remote Installation Configuration","permalink":"/docs/configuration/linking/link_remote_configuration"},"next":{"title":"Dashboard Pending Tasks","permalink":"/docs/dashboard/pending_tasks"}}');var t=i(74848),r=i(28453);const o={title:"Unmanic Workflow",description:"How Unmanic processes files from discovery to completion",id:"workflow"},l=void 0,c={},a=[{value:"File Discovery",id:"file-discovery",level:2},{value:"File Testing",id:"file-testing",level:2},{value:"API Endpoints",id:"api-endpoints",level:3},{value:"File Test Plugin Execution",id:"file-test-plugin-execution",level:3},{value:"Worker Processing",id:"worker-processing",level:2},{value:"Plugin File Testing",id:"plugin-file-testing",level:3},{value:"The Unmanic Cache",id:"the-unmanic-cache",level:3},{value:"Plugin Chaining",id:"plugin-chaining",level:3},{value:"Task Completion",id:"task-completion",level:2},{value:"Default File Movement Behavior",id:"default-file-movement-behavior",level:3},{value:"Post-processor Flows",id:"post-processor-flows",level:3},{value:"Summary",id:"summary",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["This section describes the complete workflow that Unmanic follows when processing files, from initial discovery through to final output.\nMuch of this is represented in the flowchart displayed in the ",(0,t.jsx)(n.a,{href:"/docs/configuration/plugins/overview",children:"Plugins Overview"})," section, but this provides some additional context."]}),"\n",(0,t.jsx)(n.h2,{id:"file-discovery",children:"File Discovery"}),"\n",(0,t.jsx)(n.p,{children:"Files enter Unmanic's processing pipeline through one of three methods:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Library Scanning"}),": Unmanic periodically scans configured library paths to discover files"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Event Monitoring"}),": Unmanic watches for file system events and reacts to new or modified files in real-time"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"API Submission"}),": External scripts or applications submit specific files via the API"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Files discovered through library scanning or event monitoring proceed to file testing to determine if they need processing.\nAPI submission works differently\u2014see the File Testing section below for details."}),"\n",(0,t.jsx)(n.h2,{id:"file-testing",children:"File Testing"}),"\n",(0,t.jsxs)(n.p,{children:["When a file is discovered through scanning or event monitoring, Unmanic runs it through the ",(0,t.jsx)(n.strong,{children:"Library Management - File Test"})," plugins configured for that library.\nThese plugins examine the file to determine whether it needs processing."]}),"\n",(0,t.jsx)(n.h3,{id:"api-endpoints",children:"API Endpoints"}),"\n",(0,t.jsx)(n.p,{children:"The API provides two separate endpoints for file submission:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"/api/v2/pending/create"})}),": Adds the file directly to the pending tasks queue without running file test plugins. Use this when you have already determined externally that the file needs processing."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"/api/v2/pending/test"})}),": Runs the file through the library's file test plugins but does not add it to the queue. Use this to check whether a file would be processed without actually queuing it."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This separation allows scripts to either test files before deciding to queue them, or bypass testing entirely when the decision has already been made."}),"\n",(0,t.jsx)(n.h3,{id:"file-test-plugin-execution",children:"File Test Plugin Execution"}),"\n",(0,t.jsx)(n.p,{children:"For files discovered through scanning or event monitoring, file test plugins execute in the order defined in your library's plugin flow.\nEach plugin inspects the file and can either:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Request a task"}),": Mark the file for processing, which adds it to the pending tasks queue"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Request ignore"}),": Explicitly skip this file, preventing further testing"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Pass"}),": Allow the next plugin in the flow to test the file"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Testing stops"})," as soon as any plugin requests a task or requests ignore.\nIf all file test plugins pass without requesting action, the file is not added to the queue."]}),"\n",(0,t.jsx)(n.p,{children:"This means you should order your file test plugins carefully\u2014place broader filters before specific ones to ensure efficient testing."}),"\n",(0,t.jsx)(n.h2,{id:"worker-processing",children:"Worker Processing"}),"\n",(0,t.jsxs)(n.p,{children:["Once a file is on the pending tasks queue\u2014whether placed there by file test plugins, the ",(0,t.jsx)(n.code,{children:"/api/v2/pending/create"})," endpoint, or any other method\u2014it follows the same processing path from this point forward."]}),"\n",(0,t.jsxs)(n.p,{children:["When a worker picks up a task from the pending queue, it begins executing the ",(0,t.jsx)(n.strong,{children:"Worker - Process"})," plugins for that library."]}),"\n",(0,t.jsx)(n.h3,{id:"plugin-file-testing",children:"Plugin File Testing"}),"\n",(0,t.jsx)(n.p,{children:"Each worker process plugin performs its own internal test before running.\nThis is necessary because a file may have been added to the queue by a different plugin, and the current plugin may not need to take any action on it."}),"\n",(0,t.jsx)(n.p,{children:"For example, if Plugin A added a file to the queue because it detected an incorrect video codec, Plugin B (which handles audio normalization) will still test the file but may determine that no audio work is needed."}),"\n",(0,t.jsx)(n.h3,{id:"the-unmanic-cache",children:"The Unmanic Cache"}),"\n",(0,t.jsxs)(n.p,{children:["Unmanic uses a cache directory (typically ",(0,t.jsx)(n.code,{children:"/tmp/unmanic"}),") as a working area for file processing.\nWhen a plugin needs to modify a file, it writes its output to this cache directory rather than directly to your library."]}),"\n",(0,t.jsx)(n.p,{children:"This approach:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Protects your original files until processing is complete"}),"\n",(0,t.jsx)(n.li,{children:"Provides a consistent temporary workspace for all plugins"}),"\n",(0,t.jsx)(n.li,{children:"Allows the processing pipeline to be atomic\u2014either fully successful or no changes are made"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"plugin-chaining",children:"Plugin Chaining"}),"\n",(0,t.jsx)(n.p,{children:"Worker process plugins execute in sequence, with each plugin's output becoming the next plugin's input."}),"\n",(0,t.jsx)(n.p,{children:"For example, in a video processing workflow:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Plugin A reads the original file and writes a transcoded version to the cache"}),"\n",(0,t.jsx)(n.li,{children:"Plugin B reads Plugin A's output from the cache, adds audio normalization, and writes a new file to the cache"}),"\n",(0,t.jsx)(n.li,{children:"Plugin C reads Plugin B's output and performs final adjustments"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This chaining continues through all worker process plugins configured for the library."}),"\n",(0,t.jsx)(n.h2,{id:"task-completion",children:"Task Completion"}),"\n",(0,t.jsx)(n.p,{children:"Once all worker process plugins have finished, Unmanic determines whether the task was successful and proceeds to post-processing."}),"\n",(0,t.jsx)(n.h3,{id:"default-file-movement-behavior",children:"Default File Movement Behavior"}),"\n",(0,t.jsxs)(n.p,{children:["By default, if the task completed successfully, Unmanic ",(0,t.jsx)(n.strong,{children:"overwrites the original source file"})," in the library with the processed output from the cache.\nThis is Unmanic's standard behavior\u2014replacing source files with their processed versions."]}),"\n",(0,t.jsx)(n.p,{children:"If the task failed, the original file is left untouched and the cache contents are discarded."}),"\n",(0,t.jsx)(n.h3,{id:"post-processor-flows",children:"Post-processor Flows"}),"\n",(0,t.jsx)(n.p,{children:"After worker processing completes, Unmanic executes the post-processor plugin flows:"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Post-processor - File Movement"})," plugins run first.\nThese plugins can alter Unmanic's default file movement behavior.\nFor example, the ",(0,t.jsx)(n.strong,{children:"Mover2"})," plugin allows you to customize where processed files are written, move files to different directories, or implement custom naming schemes instead of overwriting the original."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Post-processor - Task Results"})," plugins run last.\nThese handle other necessary post-processing behaviors that may be unique to each plugin, such as:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Sending notifications (Discord, email, webhooks)"}),"\n",(0,t.jsx)(n.li,{children:"Updating media servers (Plex, Jellyfin, Emby)"}),"\n",(0,t.jsx)(n.li,{children:"Logging results or updating databases"}),"\n",(0,t.jsx)(n.li,{children:"Triggering external scripts or applications"}),"\n",(0,t.jsx)(n.li,{children:"Cache file cleanup"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(n.p,{children:"The complete Unmanic workflow:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Discovery"}),": Files are found via scanning, event monitoring, or API"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"File Testing"}),": Library file test plugins determine if processing is needed"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Queuing"}),": Files that need processing are added to the pending tasks queue"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Worker Processing"}),": Workers execute process plugins in sequence, using the cache for output"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"File Movement"}),": Post-processor plugins handle final file placement (default: overwrite source)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Results Processing"}),": Post-processor plugins handle notifications and cleanup"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Understanding this workflow helps you design effective plugin flows and troubleshoot processing issues."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453(e,n,i){i.d(n,{R:()=>o,x:()=>l});var s=i(96540);const t={},r=s.createContext(t);function o(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);