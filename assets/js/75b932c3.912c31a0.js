"use strict";(globalThis.webpackChunkunmanic_documentation=globalThis.webpackChunkunmanic_documentation||[]).push([[8037],{25701(e,n,i){i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"configuration/linking/link_overview","title":"Link Overview","description":"Unmanic Configuration - Link - Overview","source":"@site/docs/configuration/linking/link_overview.mdx","sourceDirName":"configuration/linking","slug":"/configuration/linking/link_overview","permalink":"/docs/configuration/linking/link_overview","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Link Overview","description":"Unmanic Configuration - Link - Overview","id":"link_overview"},"sidebar":"docs","previous":{"title":"Configuring Plugins","permalink":"/docs/configuration/plugins/configuring_plugins"},"next":{"title":"Local Link Settings","permalink":"/docs/configuration/linking/link_local_settings"}}');var a=i(74848),o=i(28453);const r={title:"Link Overview",description:"Unmanic Configuration - Link - Overview",id:"link_overview"},s=void 0,l={},c=[{value:"How linking works",id:"how-linking-works",level:2},{value:"Remote Task flow diagram",id:"remote-task-flow-diagram",level:2},{value:"Shared library path behavior for Remote Task",id:"shared-library-path-behavior-for-remote-task",level:2},{value:"Selective routing with matching library names",id:"selective-routing-with-matching-library-names",level:2},{value:"How to think about it",id:"how-to-think-about-it",level:3},{value:"Recommended setup pattern",id:"recommended-setup-pattern",level:3},{value:"Detailed example: mixed GPU fleet",id:"detailed-example-mixed-gpu-fleet",level:3},{value:"Example flows",id:"example-flows",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",mermaid:"mermaid",ol:"ol",p:"p",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"Linking lets multiple Unmanic installations cooperate so tasks can be processed across machines while keeping control in one place."}),"\n",(0,a.jsx)(n.h2,{id:"how-linking-works",children:"How linking works"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"A local installation connects to one or more remote installations."}),"\n",(0,a.jsx)(n.li,{children:"Tasks are queued on the local installation."}),"\n",(0,a.jsx)(n.li,{children:"When a remote installation is available and configured to receive tasks, tasks are assigned to it."}),"\n",(0,a.jsx)(n.li,{children:"The task is processed on the remote worker and results are returned to the local installation for post-processing."}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"remote-task-flow-diagram",children:"Remote Task flow diagram"}),"\n",(0,a.jsx)("div",{className:"mermaid-sequence",children:(0,a.jsx)(n.mermaid,{value:'%%{init: {"theme":"base","themeVariables":{\n  "fontFamily":"system-ui, -apple-system, Segoe UI, sans-serif",\n  "primaryColor":"#0f172a",\n  "primaryTextColor":"#e2e8f0",\n  "primaryBorderColor":"#38bdf8",\n  "lineColor":"#94a3b8",\n  "actorBorder":"#38bdf8",\n  "actorBkg":"#111827",\n  "noteBkgColor":"#0f172a",\n  "noteBorderColor":"#38bdf8",\n  "labelBoxBkgColor":"#111827",\n  "labelBoxBorderColor":"#38bdf8"\n}}}%%\nsequenceDiagram\n  autonumber\n  box Local Installation\n    participant LocPending as Pending Task Queue\n    participant Foreman as Foreman\n    participant LocalPost as Post-processor\n    participant LinkMgr as Link manager\n  end\n  box Remote Installation\n    participant RmtAPI as Web API\n    participant RmtPending as Pending Task Queue\n    participant RmtForeman as Foreman\n    participant Worker as Worker\n    participant RmtPost as Post-processor\n  end\n\n  LocPending->>Foreman: Task ready\n  Foreman->>LinkMgr: Hand off task as remote\n  loop Periodic link heartbeat\n    LinkMgr->>RmtAPI: Probe API for availability/workers\n  end\n  LinkMgr->>RmtAPI: Create remote pending task\n  RmtAPI->>RmtPending: Register remote task\n  LinkMgr->>RmtAPI: Upload file payload\n  RmtAPI->>RmtPending: Cache file for task\n  RmtPending->>RmtForeman: Remote task ready\n  RmtForeman->>Worker: Assign task to worker\n  Worker--\x3e>RmtForeman: Task processed\n  RmtForeman->>RmtPost: Hand off for completion\n  RmtPost--\x3e>RmtAPI: Mark remote task complete without post-processing\n  loop Local status polling\n    LinkMgr->>RmtAPI: Fetch task status\n  end\n  RmtAPI--\x3e>LinkMgr: Task complete\n  LinkMgr->>RmtAPI: Download completed file + metadata\n  LinkMgr->>Foreman: Return completed task + metadata\n  Foreman->>LocalPost: Post-process task results'})}),"\n",(0,a.jsx)(n.h2,{id:"shared-library-path-behavior-for-remote-task",children:"Shared library path behavior for Remote Task"}),"\n",(0,a.jsxs)(n.p,{children:["If both installations can access the same files, the library paths must resolve to the same directory, even if the configured path strings are different on each machine. For example, a network share might be mounted as ",(0,a.jsx)(n.code,{children:"/mnt/media/library"})," on the local host and ",(0,a.jsx)(n.code,{children:"/media/library"})," on the remote host. In that case, each library points to its own local mount path, but both mounts reference the same underlying storage. When the matching file is reachable relative to the configured library path, the remote Unmanic installation reads it from the shared location instead of uploading the file through the API."]}),"\n",(0,a.jsx)("div",{className:"mermaid-sequence",children:(0,a.jsx)(n.mermaid,{value:'%%{init: {"theme":"base","themeVariables":{\n  "fontFamily":"system-ui, -apple-system, Segoe UI, sans-serif",\n  "primaryColor":"#0f172a",\n  "primaryTextColor":"#e2e8f0",\n  "primaryBorderColor":"#38bdf8",\n  "lineColor":"#94a3b8",\n  "actorBorder":"#38bdf8",\n  "actorBkg":"#111827",\n  "noteBkgColor":"#0f172a",\n  "noteBorderColor":"#38bdf8",\n  "labelBoxBkgColor":"#111827",\n  "labelBoxBorderColor":"#38bdf8"\n}}}%%\nsequenceDiagram\n  autonumber\n  box Local Installation\n    participant LocalPost as Post-processor\n    participant LinkMgr as Link manager\n  end\n  box Remote Installation\n    participant RmtAPI as Web API\n    participant RmtPending as Pending Task Queue\n    participant RmtForeman as Foreman\n    participant Worker as Worker\n    participant RmtPost as Post-processor\n  end\n  participant Mount as Shared library path\n\n  LinkMgr->>RmtAPI: Check shared library path for task\n  RmtAPI--\x3e>LinkMgr: Shared path exists\n  LinkMgr->>RmtAPI: Create remote task with relative path\n  RmtAPI->>RmtPending: Register remote task\n  RmtPending->>RmtForeman: Remote task ready\n  RmtForeman->>Worker: Assign task to worker\n  Worker->>Mount: Read file from shared path\n  Worker--\x3e>RmtForeman: Task processed\n  RmtForeman->>RmtPost: Hand off for completion\n  RmtPost--\x3e>RmtAPI: Mark remote task complete without post-processing\n  loop Local status polling\n    LinkMgr->>RmtAPI: Fetch task status\n  end\n  RmtAPI--\x3e>LinkMgr: Task complete\n  LinkMgr->>RmtAPI: Download completed file + metadata\n  LinkMgr->>LocalPost: Post-process task results'})}),"\n",(0,a.jsxs)(n.admonition,{type:"note",children:[(0,a.jsx)(n.p,{children:"For remote tasks, the remote post-processor first tries to move the final cache file into a temporary directory alongside the original source path (on the shared library path) if it is writable. If that move fails, it falls back to keeping the file in the Unmanic cache, and the local installation downloads it over HTTP."}),(0,a.jsx)(n.p,{children:"If the local installation only needs to move the processed file to replace the original, post-processing is faster."})]}),"\n",(0,a.jsx)(n.h2,{id:"selective-routing-with-matching-library-names",children:"Selective routing with matching library names"}),"\n",(0,a.jsx)(n.p,{children:"Linked task routing is based on library names and link configuration, not on worker capability tags across installations. A local installation will only send tasks to a linked remote installation when the link is enabled to receive tasks, the remote is reachable, and the remote has a library with the same name as the local task's library. Once the task arrives remotely, the remote installation applies its own library settings, tags, and plugins to process the task."}),"\n",(0,a.jsx)(n.p,{children:'This means you can control where tasks go by selectively creating matching libraries on the installations that are capable of handling them. If a linked installation does not have a library with the same name, it will not receive tasks for that library. If you want tight control over which libraries appear remotely, disable the "Auto-configure missing libraries on the remote installation" option in the link configuration so libraries are only created when you explicitly configure them.'}),"\n",(0,a.jsx)(n.h3,{id:"how-to-think-about-it",children:"How to think about it"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Routing decision: made by the local installation using link configuration and matching library names."}),"\n",(0,a.jsx)(n.li,{children:"Processing decision: made by the remote installation using its local library tags and plugin configuration."}),"\n",(0,a.jsx)(n.li,{children:"Worker tags: only filter workers locally on the installation that is processing the task."}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"recommended-setup-pattern",children:"Recommended setup pattern"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Pick a shared library name, for example ",(0,a.jsx)(n.code,{children:"Media"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:["Create the ",(0,a.jsx)(n.code,{children:"Media"})," library on each installation you want to receive tasks for that library."]}),"\n",(0,a.jsx)(n.li,{children:"Configure plugins differently per installation based on hardware capability."}),"\n",(0,a.jsx)(n.li,{children:"Leave the library absent on installations that should never receive that library's tasks."}),"\n",(0,a.jsx)(n.li,{children:"Optionally use library and worker tags on each installation to route tasks within that installation."}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"detailed-example-mixed-gpu-fleet",children:"Detailed example: mixed GPU fleet"}),"\n",(0,a.jsx)(n.p,{children:"You have three linked installations with different accelerators:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"MacBook (M4): Hardware acceleration for Apple VideoToolbox."}),"\n",(0,a.jsx)(n.li,{children:"Server (NVIDIA): Transcoding with NVENC and NVDEC."}),"\n",(0,a.jsx)(n.li,{children:"NUC (Intel): Transcoding with Intel Quick Sync."}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["Use the same library name on each installation, for example ",(0,a.jsx)(n.code,{children:"Media"}),', but configure the "Transcode Video" plugin differently on each:']}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["MacBook ",(0,a.jsx)(n.code,{children:"Media"})," library: set the encoder and hardware options for VideoToolbox."]}),"\n",(0,a.jsxs)(n.li,{children:["Server ",(0,a.jsx)(n.code,{children:"Media"})," library: set the encoder and hardware options for NVENC/NVDEC."]}),"\n",(0,a.jsxs)(n.li,{children:["NUC ",(0,a.jsx)(n.code,{children:"Media"})," library: set the encoder and hardware options for Intel QSV."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["With this setup, the local installation can send any ",(0,a.jsx)(n.code,{children:"Media"})," tasks to any linked installation that has the ",(0,a.jsx)(n.code,{children:"Media"})," library. Each remote installation will process the task using its own plugin settings, so the same library can be optimized for Apple, NVIDIA, or Intel hardware depending on where the task lands."]}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:['You can still use "Automatically configure missing libraries on the remote installation" if you want a one-time push of the local library configuration to a new remote installation, then edit plugin settings independently on each install. That option only creates missing libraries and does not keep them in sync after the initial push. See ',(0,a.jsx)(n.a,{href:"./link_remote_configuration",children:"Remote Installation Configuration"}),"."]})}),"\n",(0,a.jsx)(n.admonition,{type:"warning",children:(0,a.jsx)(n.p,{children:'If "Automatically configure missing libraries on the remote installation" is enabled, every local library can be created remotely, which effectively allows tasks from all libraries to be sent to that installation. If you want to prevent certain libraries from ever sending tasks to a remote installation, turn this option off and create only the libraries you want on that remote.'})}),"\n",(0,a.jsx)(n.h3,{id:"example-flows",children:"Example flows"}),"\n",(0,a.jsx)(n.p,{children:"Example 1: Remote library exists"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Local ",(0,a.jsx)(n.code,{children:"Media"})," library queues a task."]}),"\n",(0,a.jsxs)(n.li,{children:["Link manager sees that the remote installation is enabled to receive tasks and has a ",(0,a.jsx)(n.code,{children:"Media"})," library."]}),"\n",(0,a.jsx)(n.li,{children:"Task is sent to the remote installation."}),"\n",(0,a.jsxs)(n.li,{children:["Remote installation applies its local ",(0,a.jsx)(n.code,{children:"Media"})," library settings and plugin configuration."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Example 2: Remote library missing"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Local ",(0,a.jsx)(n.code,{children:"Media"})," library queues a task."]}),"\n",(0,a.jsx)(n.li,{children:"Link manager checks available remote installations."}),"\n",(0,a.jsxs)(n.li,{children:["Remote installation does not have a ",(0,a.jsx)(n.code,{children:"Media"})," library."]}),"\n",(0,a.jsx)(n.li,{children:"Task is not sent to that remote installation."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Example 3: Auto-configure enabled"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Local ",(0,a.jsx)(n.code,{children:"Media"})," library queues a task."]}),"\n",(0,a.jsxs)(n.li,{children:["Link manager sees auto-configure enabled and creates the missing ",(0,a.jsx)(n.code,{children:"Media"})," library on the remote installation."]}),"\n",(0,a.jsx)(n.li,{children:"The auto-configured library is set to receive remote-only tasks with scanning disabled, so no library path is configured."}),"\n",(0,a.jsx)(n.li,{children:"The task is sent and processed, and the transfer uses the HTTP upload/download flow instead of a shared library path."}),"\n",(0,a.jsx)(n.li,{children:"If you want shared library path behavior, then you would need to manually configure the remote library with the correct path."}),"\n"]}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["For verbose logging, enable ",(0,a.jsx)(n.code,{children:"EnableDebugging"})," on each installation under the Logs section of the Help & Support page. When debugging is enabled, you will see details about link availability, remote task creation, file transfers, and worker assignment in the logs. This is useful for confirming that libraries are matching as expected and that tasks are being processed with the correct plugin configuration on each machine."]})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453(e,n,i){i.d(n,{R:()=>r,x:()=>s});var t=i(96540);const a={},o=t.createContext(a);function r(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);