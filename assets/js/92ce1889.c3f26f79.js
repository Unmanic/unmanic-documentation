"use strict";(globalThis.webpackChunkunmanic_documentation=globalThis.webpackChunkunmanic_documentation||[]).push([[7832],{28453(e,n,s){s.d(n,{R:()=>r,x:()=>l});var i=s(96540);const t={},a=i.createContext(t);function r(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),i.createElement(a.Provider,{value:n},e.children)}},90908(e,n,s){s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"development/writing_plugins/sharing_data_between_plugins","title":"Sharing Data Between Plugins","description":"Plugin workflows often need to share state between runners and between different plugins in a single task. Unmanic provides helper classes to make this safe and consistent without plugins needing to manage their own storage.","source":"@site/docs/development/writing_plugins/sharing_data_between_plugins.mdx","sourceDirName":"development/writing_plugins","slug":"/development/writing_plugins/sharing_data_between_plugins","permalink":"/docs/development/writing_plugins/sharing_data_between_plugins","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"sharing_data_between_plugins","title":"Sharing Data Between Plugins"},"sidebar":"docs","previous":{"title":"Accessing System Info","permalink":"/docs/development/writing_plugins/system_info"},"next":{"title":"Plugin Runners","permalink":"/docs/development/writing_plugins/plugin_runner_types"}}');var t=s(74848),a=s(28453);const r={id:"sharing_data_between_plugins",title:"Sharing Data Between Plugins"},l=void 0,d={},o=[{value:"TaskDataStore",id:"taskdatastore",level:2},{value:"Stores and behavior",id:"stores-and-behavior",level:3},{value:"API summary",id:"api-summary",level:3},{value:"Example usage",id:"example-usage",level:3},{value:"Recommended signature style",id:"recommended-signature-style",level:3},{value:"Limitations",id:"limitations",level:3},{value:"Directory metadata (.unmanic) (deprecated)",id:"directory-metadata-unmanic-deprecated",level:2},{value:"Example usage",id:"example-usage-1",level:3},{value:"Notes",id:"notes",level:3},{value:"API summary",id:"api-summary-1",level:3},{value:"Function:",id:"function",level:4},{value:"Function:",id:"function-1",level:4},{value:"Function:",id:"function-2",level:4},{value:"UnmanicFileMetadata",id:"unmanicfilemetadata",level:2},{value:"How it works",id:"how-it-works",level:3},{value:"Key behavior",id:"key-behavior",level:3},{value:"Read-only in file test runners",id:"read-only-in-file-test-runners",level:3},{value:"Read/write during task processing",id:"readwrite-during-task-processing",level:3},{value:"Writing against the source fingerprint",id:"writing-against-the-source-fingerprint",level:3},{value:"Backward compatibility with <code>.unmanic</code>",id:"backward-compatibility-with-unmanic",level:3},{value:"API summary",id:"api-summary-2",level:3},{value:"Function:",id:"function-3",level:4},{value:"Function:",id:"function-4",level:4},{value:"Choosing the right helper",id:"choosing-the-right-helper",level:2}];function c(e){const n={admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Plugin workflows often need to share state between runners and between different plugins in a single task. Unmanic provides helper classes to make this safe and consistent without plugins needing to manage their own storage."}),"\n",(0,t.jsx)(n.h2,{id:"taskdatastore",children:"TaskDataStore"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"TaskDataStore"})," is a task-scoped, in-memory store that allows plugins to share data during the lifecycle of a task. Use it when the data only matters while a task is active and should not persist once the task is complete."]}),"\n",(0,t.jsx)(n.h3,{id:"stores-and-behavior",children:"Stores and behavior"}),"\n",(0,t.jsx)(n.p,{children:"TaskDataStore has two separate stores:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Runner State (immutable)"}),"\n"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Stored per ",(0,t.jsx)(n.code,{children:"(task_id, plugin_id, runner)"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["A key can only be set once; subsequent sets return ",(0,t.jsx)(n.code,{children:"False"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"Intended for recording values that should not be mutated later in the task flow."}),"\n"]}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsx)(n.li,{children:"Task State (mutable)"}),"\n"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Stored per ",(0,t.jsx)(n.code,{children:"task_id"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"Keys can be created, updated, deleted, and exported/imported as JSON."}),"\n",(0,t.jsx)(n.li,{children:"Intended for shared, mutable state across plugins during the task lifecycle."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"api-summary",children:"API summary"}),"\n",(0,t.jsx)(n.p,{children:"Runner state (immutable):"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"set_runner_value(key, value) -> bool"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"get_runner_value(key, default=None, plugin_id=None, runner=None) -> Any"})}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Task state (mutable):"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"set_task_state(key, value, task_id=None)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"get_task_state(key, default=None, task_id=None) -> Any"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"delete_task_state(key, task_id=None)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"export_task_state(task_id) -> dict"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"export_task_state_json(task_id, **json_kwargs) -> str"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"import_task_state(task_id, new_state: dict)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"import_task_state_json(task_id, json_data: str)"})}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"example-usage",children:"Example usage"}),"\n",(0,t.jsx)(n.p,{children:"Immutable runner value:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def emit_task_scheduled(data, task_data_store=None):\n    task_data_store.set_runner_value("source_size", data["source_data"]["size"])\n'})}),"\n",(0,t.jsx)(n.p,{children:"Reading the value later in the same task:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def on_postprocessor_task_results(data, task_data_store=None):\n    source_size = task_data_store.get_runner_value("source_size", runner="emit_task_scheduled")\n'})}),"\n",(0,t.jsx)(n.p,{children:"Mutable task state:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def on_worker_process(data, task_data_store=None):\n    task_data_store.set_task_state("progress_marker", "stage_1_complete")\n    return data\n'})}),"\n",(0,t.jsx)(n.h3,{id:"recommended-signature-style",children:"Recommended signature style"}),"\n",(0,t.jsx)(n.p,{children:"New plugins should use keyword arguments so Unmanic can pass helpers by name:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def on_worker_process(data, task_data_store=None, file_metadata=None):\n    task_data_store.set_task_state("source_file_size", source_file_size)\n'})}),"\n",(0,t.jsx)(n.h3,{id:"limitations",children:"Limitations"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"In-memory only: data is lost on restart or crash."}),"\n",(0,t.jsx)(n.li,{children:"Task lifecycle only: data is cleared when a task is deleted or marked complete."}),"\n",(0,t.jsxs)(n.li,{children:["Requires runner context: if no context is bound, calls will raise ",(0,t.jsx)(n.code,{children:"RuntimeError"})," unless a ",(0,t.jsx)(n.code,{children:"task_id"})," override is provided where supported."]}),"\n",(0,t.jsx)(n.li,{children:"No cross-process support: this is thread-safe but not shared across separate processes."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"directory-metadata-unmanic-deprecated",children:"Directory metadata (.unmanic) (deprecated)"}),"\n",(0,t.jsxs)(n.p,{children:["Plugins can store lightweight, per-directory metadata in a hidden ",(0,t.jsx)(n.code,{children:".unmanic"})," file using ",(0,t.jsx)(n.code,{children:"UnmanicDirectoryInfo"}),".\nThis is useful for persisting plugin decisions (for example, marking a file as already moved or skipping a failed move) without maintaining your own database.\nThe Mover2 plugin in the official repository uses this helper to track file movement attempts."]}),"\n",(0,t.jsx)(n.admonition,{type:"warning",children:(0,t.jsxs)(n.p,{children:["This feature is deprecated in favor of the database-backed ",(0,t.jsx)(n.code,{children:"UnmanicFileMetadata"})," helper class described below, and ",(0,t.jsx)(n.code,{children:".unmanic"})," support may be removed in a future Unmanic update."]})}),"\n",(0,t.jsx)(n.h3,{id:"example-usage-1",children:"Example usage"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import os\nfrom unmanic.libs.directoryinfo import UnmanicDirectoryInfo\n\ndef mark_file_as_moved(path):\n    directory_info = UnmanicDirectoryInfo(os.path.dirname(path))\n    directory_info.set('mover2', os.path.basename(path), 'Moved')\n    directory_info.save()\n\ndef file_was_marked(path):\n    directory_info = UnmanicDirectoryInfo(os.path.dirname(path))\n    return directory_info.get('mover2', os.path.basename(path)) == 'Moved'\n"})}),"\n",(0,t.jsx)(n.h3,{id:"notes",children:"Notes"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:".unmanic"})," file is stored alongside the files in each directory and is created on first save."]}),"\n",(0,t.jsx)(n.li,{children:"Options are stored in lower case, so treat keys as case-insensitive."}),"\n",(0,t.jsxs)(n.li,{children:["Always call ",(0,t.jsx)(n.code,{children:"save()"})," after setting values or your changes will not be persisted."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"api-summary-1",children:"API summary"}),"\n",(0,t.jsx)(n.h4,{id:"function",children:"Function:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"get(section, option, fallback=None)"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"section"})})," ",(0,t.jsx)(n.em,{children:"[string]"})," - The plugin ID or namespace you want to read."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"option"})})," ",(0,t.jsx)(n.em,{children:"[string]"})," - The key stored for the file."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"fallback"})})," ",(0,t.jsx)(n.em,{children:"[any]"})," - Optional default if the key does not exist."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"function-1",children:"Function:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"set(section, option, value)"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"section"})})," ",(0,t.jsx)(n.em,{children:"[string]"})," - The plugin ID or namespace to write."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"option"})})," ",(0,t.jsx)(n.em,{children:"[string]"})," - The key to set for the file."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"value"})})," ",(0,t.jsx)(n.em,{children:"[string]"})," - The value to store."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"function-2",children:"Function:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"save()"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"No arguments"})," - Persists any pending changes to disk."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"unmanicfilemetadata",children:"UnmanicFileMetadata"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"UnmanicFileMetadata"})," stores file-level metadata that persists across tasks and survives renames or moves by using a content fingerprint."]}),"\n",(0,t.jsx)(n.p,{children:"The Mover2 and Video Transcoder plugins are good references:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Mover2"})," shows how to write ",(0,t.jsx)(n.strong,{children:"source-scoped"})," metadata so the next scan can skip the original file."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Video Transcoder"})," uses ",(0,t.jsx)(n.strong,{children:"destination-scoped"})," metadata for the \u201cforce transcode\u201d feature."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"how-it-works",children:"How it works"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"During task processing, metadata is staged against the task in a temporary table."}),"\n",(0,t.jsx)(n.li,{children:"When the task is written to history, the metadata is committed to the long-lived file metadata table using a content fingerprint."}),"\n",(0,t.jsx)(n.li,{children:"File metadata persists even if completed tasks are deleted or cleaned up; scheduled cleanup does not remove file metadata."}),"\n",(0,t.jsx)(n.li,{children:"File test runners can read metadata by file path, but they cannot write because no task exists yet."}),"\n",(0,t.jsx)(n.li,{children:"Task staging stores source and destination scopes separately and preserves the source fingerprint at first source-scoped write so it can be committed even if the source file changes later."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"key-behavior",children:"Key behavior"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"File-scoped: data persists beyond task completion."}),"\n",(0,t.jsx)(n.li,{children:"Shared across plugins: any plugin can read metadata written by another plugin."}),"\n",(0,t.jsx)(n.li,{children:"Write restrictions: plugins may only write to their own namespace."}),"\n",(0,t.jsx)(n.li,{children:"Not tied to completed tasks cleanup: deleting completed tasks does not delete file metadata."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"read-only-in-file-test-runners",children:"Read-only in file test runners"}),"\n",(0,t.jsx)(n.p,{children:"File test runners can read metadata by path but cannot write because no task exists yet."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def on_library_management_file_test(data, file_metadata=None):\n    existing = file_metadata.get()\n    if existing.get("ignore"):\n        data["add_file_to_pending_tasks"] = False\n        data["ignore_file"] = True\n'})}),"\n",(0,t.jsx)(n.h3,{id:"readwrite-during-task-processing",children:"Read/write during task processing"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def on_worker_process(data, file_metadata=None):\n    current = file_metadata.get()\n    if current.get("ignore"):\n        return data\n\n    file_metadata.set({"status": "processed", "ignore": True})\n    return data\n'})}),"\n",(0,t.jsx)(n.h3,{id:"writing-against-the-source-fingerprint",children:"Writing against the source fingerprint"}),"\n",(0,t.jsxs)(n.p,{children:["By default, ",(0,t.jsx)(n.code,{children:"set()"})," writes metadata that will be committed against the source fingerprint. If your plugin needs to persist metadata for the destination file(s) on success, pass ",(0,t.jsx)(n.code,{children:"use_destination_scope=True"}),". A plugin can write both scopes by calling ",(0,t.jsx)(n.code,{children:"set()"})," twice with different ",(0,t.jsx)(n.code,{children:"use_destination_scope"})," values."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def on_postprocessor_file_movement(data, file_metadata=None):\n    # Persist metadata for the original source file, even if a new destination file is created.\n    file_metadata.set({"status": "Ignoring"})\n    return data\n'})}),"\n",(0,t.jsxs)(n.h3,{id:"backward-compatibility-with-unmanic",children:["Backward compatibility with ",(0,t.jsx)(n.code,{children:".unmanic"})]}),"\n",(0,t.jsxs)(n.p,{children:["If your plugin needs to remain compatible with older Unmanic versions that do not expose ",(0,t.jsx)(n.code,{children:"file_metadata"}),", use a fallback to ",(0,t.jsx)(n.code,{children:".unmanic"})," only when the helper is unavailable. This mirrors the approach in Mover2."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'def on_postprocessor_file_movement(data, file_metadata=None):\n    source_path = data.get("source_data", {}).get("abspath")\n    if file_metadata:\n        file_metadata.set({"status": "Ignoring"})\n    else:\n        directory_info = UnmanicDirectoryInfo(os.path.dirname(source_path))\n        directory_info.set("mover2", os.path.basename(source_path), "Ignoring")\n        directory_info.save()\n'})}),"\n",(0,t.jsx)(n.h3,{id:"api-summary-2",children:"API summary"}),"\n",(0,t.jsx)(n.h4,{id:"function-3",children:"Function:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"get(plugin_id_override=None)"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"plugin_id_override"})})," ",(0,t.jsx)(n.em,{children:"[string]"})," - Optional plugin ID to read another plugin\u2019s metadata namespace."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"function-4",children:"Function:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"set(data, use_destination_scope=False)"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"data"})})," ",(0,t.jsx)(n.em,{children:"[dictionary]"})," - Data to merge into your plugin\u2019s metadata namespace."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"use_destination_scope"})})," ",(0,t.jsx)(n.em,{children:"[boolean]"})," - When ",(0,t.jsx)(n.code,{children:"True"}),", commit metadata against destination fingerprints on success. Default ",(0,t.jsx)(n.code,{children:"False"})," commits against the original source fingerprint."]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"get()"})," returns the metadata scoped to your plugin ID by default."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:'get("mover2")'})," returns the metadata scoped for the mover2 plugin."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"set()"})," accepts a dictionary only and merges into your plugin\u2019s metadata namespace; set a key to ",(0,t.jsx)(n.code,{children:"None"})," to remove it."]}),"\n",(0,t.jsxs)(n.li,{children:["When ",(0,t.jsx)(n.code,{children:"use_destination_scope=False"})," (default), the source file fingerprint is captured at the first call to ",(0,t.jsx)(n.code,{children:"set()"}),"; if the source file no longer exists at commit time, the metadata is dropped and an info log is written."]}),"\n",(0,t.jsx)(n.li,{children:"Task-scoped staging stores source and destination metadata separately so a single plugin can write both scopes during the same task."}),"\n",(0,t.jsx)(n.li,{children:"The metadata size per plugin is limited (currently 32KB)."}),"\n",(0,t.jsx)(n.li,{children:"This helper is only available in the main Unmanic process; child processes cannot access it."}),"\n"]})}),"\n",(0,t.jsx)(n.h2,{id:"choosing-the-right-helper",children:"Choosing the right helper"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.code,{children:"TaskDataStore"})," when the data only matters during a task and should not persist afterward."]}),"\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.code,{children:"UnmanicFileMetadata"})," when you need to persist file-level decisions across scans, renames, or moves."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);